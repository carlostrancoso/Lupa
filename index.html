<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lupa</title>
    <style>
      html, body {
          margin: 0;
          height: 100%;
      }
      #webgl {
          width: 100%;
          height: 100%;
          display: block;
          cursor: grab;
      }
      #webgl:active {
      cursor: grabbing;
  
  }
  </style>

    <script  type="importmap">{
      "imports": {
        "three": "https://threejs.org/build/three.module.js"
      }
    }</script><!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="module">
      
     //bibliotecas
     import * as THREE from 'three';
     import {OrbitControls} from 'https://threejs.org/examples/jsm/controls/OrbitControls.js';
     import {OBJLoader} from 'https://threejs.org/examples/jsm/loaders/OBJLoader.js';
     import {MTLLoader} from 'https://threejs.org/examples/jsm/loaders/MTLLoader.js';

//loading screen

const manager = new THREE.LoadingManager();
  const loadingContainer = document.querySelector('.loading-screen')

  manager.onLoad = function ( ) {

  loadingContainer.style.display='none';

};

manager.onError = function ( url ) {

	console.log( 'There was an error loading ' + url );

};


    
      //janela e motor render
      var canvas = document.querySelector('#webgl');
      var renderer = new THREE.WebGLRenderer({canvas, alpha:true});
      renderer.setClearColor( 0xEDEDED, 0 );

      //cena e fundo 
      //const bgcolor = new THREE.Color(0xEDEDED);
      const bgcolor = new THREE.Color(0xdb4437);
      const scene = new THREE.Scene();
      scene.background = bgcolor;
    
    // Camera
    const camera = new THREE.PerspectiveCamera(75, 2, 0.1, 100)
    camera.position.z = 3
    scene.add(camera)

    // Controls
const controls = new OrbitControls(camera, canvas)
controls.enableDamping = true
controls.enabled = false

    //redimensionamento da janela

  function resizeRendererToDisplaySize(renderer) {
    var canvas = renderer.domElement;
    var width = canvas.clientWidth;
    var height = canvas.clientHeight;
    var needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

  //luz ambiente

  const light = new THREE.AmbientLight( 0xffffff, 4 ); // soft white light
  scene.add( light );


  // Object
const cube = new THREE.Mesh(
    new THREE.BoxGeometry(1, 1, 1, 5, 5, 5),
    new THREE.MeshBasicMaterial({ color: 0xff0000 })
)
scene.add(cube)
cube.visible = false

  //lupa
var lupa;
  {
    var objLoader = new OBJLoader(manager);
    var mat = new THREE.MeshPhysicalMaterial({});
mat.reflectivity = 0
mat.transmission = 1
mat.roughness = 0.2
mat.metalness = 0
mat.clearcoat = 0.3
mat.clearcoatRoughness = 0.25
mat.color = new THREE.Color(0xffffff)
mat.ior = 1.2
mat.thickness = 5

objLoader.load('LUPA.obj', function (obj) {
        obj.traverse(function (child) {

            if (child instanceof THREE.Mesh) {
                child.material = mat;
                mat.side = THREE.DoubleSide;
            }

        });
        lupa = obj;
        scene.add(lupa);
      lupa.rotation.x = Math.PI;
      lupa.rotation.z = Math.PI;
    });
    }

    //bustos

    var busto;
  {
    var mtlLoader = new MTLLoader(manager);
    mtlLoader.load('BUSTO.mtl', (mtl) => {
      mtl.preload();
      for (var material of Object.values(mtl.materials)) {
     material.side = THREE.DoubleSide;
      }
      var objLoader = new OBJLoader(manager);
      objLoader.setMaterials(mtl);
      objLoader.load('BUSTO.obj', (mesh) => {
        busto = mesh;
        scene.add(busto);
        busto.rotation.x = Math.PI;
        busto.rotation.z = Math.PI;
        busto.visible = true;
      });
    });
    
  }

  // Cursor
const cursor = {
    x: 0,
    y: 0
}
window.addEventListener('mousemove', (event) =>
{
    cursor.x = event.clientX / canvas.clientWidth - 0.5
    cursor.y = - (event.clientY / canvas.clientHeight - 0.5)

})


// Cursor
const touch = {
    x: 0,
    y: 0
}
window.addEventListener("touchmove", (event) =>
{
    touch.x = event.clientX / canvas.clientWidth - 0.5
    touch.y = - (event.clientY / canvas.clientHeight - 0.5)

})










    const tick = () =>
{
  //Update window
  if (resizeRendererToDisplaySize(renderer)) {
      var canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }


    // Update camera
    camera.position.x = Math.sin(cursor.x * Math.PI/2) * 2
    camera.position.z = Math.cos(cursor.x * Math.PI/2) * 2
    camera.position.y = cursor.y * 2
	
	camera.position.x = Math.sin(touch.x * Math.PI/2) * 2
    camera.position.z = Math.cos(touch.x * Math.PI/2) * 2
    camera.position.y = touch.y * 2
	
    camera.lookAt(cube.position)
    
     // Update controls
     controls.update()

    

    // Render
    renderer.render(scene, camera)

   

    // Call tick again on the next frame
    window.requestAnimationFrame(tick)
}

tick()



    </script> 
</head>
<body>
    <canvas id="webgl"></canvas>
</body>
</html>
